"""Data extraction utilities for benchmark profiling results.

This module provides configurable extraction of profiling metrics from cProfile
stats files and memory profiler output. The extraction is driven by CallPattern
objects that map logical names to regex patterns for matching function calls.
"""

from __future__ import annotations

import re
import subprocess
from dataclasses import dataclass
from itertools import chain
from pathlib import Path
from typing import Any

import yaml
from loguru import logger


@dataclass
class CallPattern:
    """Configuration for extracting metrics for a specific function from cProfile stats.

    Attributes
    ----------
    name
        Logical name for the metric (e.g., "gather_results", "setup"). Used as prefix
        for generated column names.
    filename
        Path pattern to match the source file (e.g., "results/manager.py").
    function_name
        Name of the function to match (e.g., "gather_results").
    extract_cumtime
        Whether to extract cumulative time. Default True.
    extract_percall
        Whether to extract time per call. Default False.
    extract_ncalls
        Whether to extract number of calls. Default False.
    cumtime_template
        Template for cumtime column name. Use {name} as placeholder.
    percall_template
        Template for percall column name. Use {name} as placeholder.
    ncalls_template
        Template for ncalls column name. Use {name} as placeholder.

    """

    name: str
    filename: str
    function_name: str
    extract_cumtime: bool = True
    extract_percall: bool = False
    extract_ncalls: bool = False
    cumtime_template: str = "{name}_cumtime"
    percall_template: str = "{name}_percall"
    ncalls_template: str = "{name}_ncalls"

    @property
    def pattern(self) -> str:
        """Regex pattern to match the function in cProfile stats output."""
        escaped_file = re.escape(self.filename)
        return rf"{escaped_file}:\d+\({self.function_name}\)"

    @property
    def cumtime_col(self) -> str:
        """Column name for cumulative time."""
        return self.cumtime_template.format(name=self.name)

    @property
    def percall_col(self) -> str:
        """Column name for time per call."""
        return self.percall_template.format(name=self.name)

    @property
    def ncalls_col(self) -> str:
        """Column name for number of calls."""
        return self.ncalls_template.format(name=self.name)

    @property
    def columns(self) -> list[str]:
        """All column names generated by this config (based on extract flags)."""
        cols = []
        if self.extract_cumtime:
            cols.append(self.cumtime_col)
        if self.extract_percall:
            cols.append(self.percall_col)
        if self.extract_ncalls:
            cols.append(self.ncalls_col)
        return cols


def bottleneck_config(name: str, filename: str, function_name: str) -> CallPattern:
    """Create a CallPattern for a bottleneck function (extracts all 3 metrics).

    Parameters
    ----------
    name
        Logical name for the bottleneck.
    filename
        Path pattern to match the source file.
    function_name
        Name of the function to match.

    Returns
    -------
        CallPattern configured for bottleneck extraction.

    """
    return CallPattern(
        name=name,
        filename=filename,
        function_name=function_name,
        extract_cumtime=True,
        extract_percall=True,
        extract_ncalls=True,
    )


def phase_config(name: str, filename: str = "/vivarium/framework/engine.py") -> CallPattern:
    """Create a CallPattern for a simulation phase (extracts cumtime only).

    Parameters
    ----------
    name
        Phase name as it appears in the cProfile output (e.g., "setup", "run").
    filename
        Path to match the source file containing the phase function.

    Returns
    -------
        CallPattern configured for phase extraction.

    """
    return CallPattern(
        name=name,
        filename=filename,
        function_name=name,
        extract_cumtime=True,
        extract_percall=False,
        extract_ncalls=False,
        cumtime_template="rt_{name}_s",
    )


# Default bottleneck configurations
DEFAULT_BOTTLENECKS = [
    bottleneck_config(
        name="gather_results",
        filename="results/manager.py",
        function_name="gather_results",
    ),
    bottleneck_config(
        name="pipeline_call",
        filename="values/pipeline.py",
        function_name="__call__",
    ),
    bottleneck_config(
        name="population_get",
        filename="population/population_view.py",
        function_name="get",
    ),
]

# Default simulation phase configurations
DEFAULT_PHASES = [
    phase_config("setup"),
    phase_config("initialize_simulants"),
    phase_config("run"),
    phase_config("finalize"),
    phase_config("report"),
]


@dataclass
class ExtractionConfig:
    """Configuration for extracting metrics from profiling results.

    Attributes
    ----------
    patterns
        List of CallPattern objects defining what metrics to extract.

    """

    def __init__(self, patterns: list[CallPattern] | None = None):
        if patterns is None:
            patterns = DEFAULT_BOTTLENECKS + DEFAULT_PHASES
        self.patterns = patterns

    @classmethod
    def from_yaml(cls, yaml_path: str | Path) -> ExtractionConfig:
        """Create an ExtractionConfig from a YAML file.

        Parameters
        ----------
        yaml_path
            Path to the YAML configuration file.

        Returns
        -------
            ExtractionConfig object with patterns defined in the YAML file.

        Raises
        ------
        ValueError
            If the YAML file is invalid or missing required fields.
        FileNotFoundError
            If the YAML file doesn't exist.

        Examples
        --------
        YAML format::

            patterns:
              - name: gather_results
                preset: bottleneck
                filename: results/manager.py
                function_name: gather_results

              - name: setup
                preset: phase
                # filename defaults to /vivarium/framework/engine.py for phases

              - name: custom_func
                filename: my/module.py
                function_name: my_function
                extract_cumtime: true
                extract_percall: true
                cumtime_template: "custom_{name}_time"

        """
        yaml_path = Path(yaml_path)
        if not yaml_path.exists():
            raise FileNotFoundError(f"YAML config file not found: {yaml_path}")

        with open(yaml_path, "r") as f:
            config_data = yaml.safe_load(f)

        if not isinstance(config_data, dict) or "patterns" not in config_data:
            raise ValueError(
                "YAML file must contain a 'patterns' key with a list of pattern definitions"
            )

        patterns = []
        for i, pattern_dict in enumerate(config_data["patterns"]):
            if not isinstance(pattern_dict, dict):
                raise ValueError(f"Pattern at index {i} must be a dictionary")

            if "name" not in pattern_dict:
                raise ValueError(f"Pattern at index {i} is missing required field 'name'")

            name = pattern_dict["name"]
            preset = pattern_dict.get("preset")

            # Handle preset shortcuts
            if preset == "bottleneck":
                if "filename" not in pattern_dict or "function_name" not in pattern_dict:
                    raise ValueError(
                        f"Pattern '{name}' with preset='bottleneck' requires "
                        "'filename' and 'function_name'"
                    )
                pattern = bottleneck_config(
                    name=name,
                    filename=pattern_dict["filename"],
                    function_name=pattern_dict["function_name"],
                )
            elif preset == "phase":
                filename = pattern_dict.get("filename", "/vivarium/framework/engine.py")
                pattern = phase_config(name=name, filename=filename)
            else:
                # Custom pattern - require filename and function_name
                if "filename" not in pattern_dict or "function_name" not in pattern_dict:
                    raise ValueError(
                        f"Pattern '{name}' requires 'filename' and 'function_name' fields"
                    )

                # Extract optional fields with defaults
                pattern = CallPattern(
                    name=name,
                    filename=pattern_dict["filename"],
                    function_name=pattern_dict["function_name"],
                    extract_cumtime=pattern_dict.get("extract_cumtime", True),
                    extract_percall=pattern_dict.get("extract_percall", False),
                    extract_ncalls=pattern_dict.get("extract_ncalls", False),
                    cumtime_template=pattern_dict.get("cumtime_template", "{name}_cumtime"),
                    percall_template=pattern_dict.get("percall_template", "{name}_percall"),
                    ncalls_template=pattern_dict.get("ncalls_template", "{name}_ncalls"),
                )

            patterns.append(pattern)

        return cls(patterns=patterns)

    @property
    def metric_names(self) -> list[str]:
        """Get the names of all configured metrics."""
        return [pattern.name for pattern in self.patterns]

    @property
    def metric_columns(self) -> list[str]:
        """Get all column names for the configured patterns."""
        return list(chain.from_iterable(pattern.columns for pattern in self.patterns))

    @property
    def results_columns(self) -> list[str]:
        """Get all column names for benchmark results CSV."""
        base_columns = ["model_spec", "run", "rt_s", "mem_mb"]
        return base_columns + self.metric_columns

    def extract_metrics(self, stats_file_txt: str | Path) -> dict[str, float | int | None]:
        """Extract metrics for all configured items from a stats file.

        Parameters
        ----------
        stats_file_txt
            Path to the .stats.txt file generated by cProfile.
        config
            Extraction configuration. Defaults to DEFAULT_CONFIG.

        Returns
        -------
            Dictionary mapping column names to extracted values.

        """

        results: dict[str, float | int | None] = {}
        for pattern in self.patterns:
            cumtime, percall, ncalls = parse_function_metrics(stats_file_txt, pattern.pattern)
            if pattern.extract_cumtime:
                results[pattern.cumtime_col] = cumtime
            if pattern.extract_percall:
                results[pattern.percall_col] = percall
            if pattern.extract_ncalls:
                results[pattern.ncalls_col] = ncalls

        return results


def get_peak_memory() -> float | None:
    """Get peak memory usage from memory profiler.

    Calls `mprof peak` to retrieve the peak memory usage from the most recent
    memory profiler run.

    Returns
    -------
        Peak memory usage in MB, or None if extraction fails.

    """
    try:
        result = subprocess.run(["mprof", "peak"], capture_output=True, text=True, check=True)
        # Extract the first decimal number from the output
        match = re.search(r"(\d+\.\d+)", result.stdout)
        if match:
            return float(match.group(1))
    except (subprocess.CalledProcessError, ValueError):
        logger.warning("Could not extract peak memory usage")
    return None


def extract_runtime(stats_file_txt: str | Path) -> float | None:
    """Extract total runtime from a cProfile stats file.

    Parameters
    ----------
    stats_file_txt
        Path to the .stats.txt file generated by cProfile.

    Returns
    -------
        Total runtime in seconds, or None if extraction fails.

    """
    try:
        with open(stats_file_txt, "r") as f:
            content = f.read()

        # Look for pattern like "12345 function calls (12340 primitive calls) in 1.234 seconds"
        match = re.search(r"function calls.*in (\d+\.\d+) seconds", content)
        if match:
            return float(match.group(1))
    except (FileNotFoundError, ValueError, OSError) as e:
        logger.warning(f"Could not extract runtime from {stats_file_txt}: {e}")
    return None


def parse_function_metrics(
    stats_file_txt: str | Path, pattern: str
) -> tuple[float | None, float | None, int | None]:
    """Parse cumtime, percall, and ncalls for a specific function pattern.

    Parameters
    ----------
    stats_file_txt
        Path to the .stats.txt file generated by cProfile.
    pattern
        Regex pattern to match the function in the stats output.

    Returns
    -------
        Tuple of (cumtime, percall, ncalls), with None values if extraction fails.

    """
    try:
        with open(stats_file_txt, "r") as f:
            content = f.read()

        # Find the line matching the pattern
        lines = content.split("\n")
        matching_line = None
        for line in lines:
            if re.search(pattern, line):
                matching_line = line
                break

        if not matching_line:
            return None, None, None

        # Parse the line - typical format:
        # "ncalls  tottime  percall  cumtime  percall filename:lineno(function)"
        parts = matching_line.split()
        if len(parts) >= 5:
            ncalls_str = parts[0]
            cumtime = float(parts[3])
            percall = float(parts[4])

            # Handle ncalls which might be in format "123/456" (recursive calls)
            if "/" in ncalls_str:
                ncalls = int(ncalls_str.split("/")[1])
            else:
                ncalls = int(ncalls_str)

            return cumtime, percall, ncalls

    except (FileNotFoundError, ValueError, IndexError, OSError) as e:
        logger.warning(
            f"Could not parse function metrics from {stats_file_txt} with pattern {pattern}: {e}"
        )

    return None, None, None
